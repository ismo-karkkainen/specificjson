#!/usr/bin/env ruby

# Copyright 2020 Ismo Kärkkäinen
# Licensed under Universal Permissive License. See License.txt.

require 'optparse'
require 'yaml'
require 'json'
require 'base64'

$CLEAN = false
$RECIPE = nil
$LIST = false
$WARN = false
$EXPORT = false
$BUILD = nil
$IN = nil

parser = OptionParser.new do |opts|
  opts.summary_indent = '  '
  opts.summary_width = 24
  opts.banner = "Usage: build [options]"
  opts.separator ""
  opts.separator "Options (handled in presented order):"
  opts.on('--clean', 'Ignore embedded information.') { $CLEAN = true }
  opts.on('--import FILELIST', 'Information YAML file list as YAML array.') { |f| $RECIPE = f }
  opts.on('--list', 'List the names that are available.') { $LIST = true }
  opts.on('--warn', 'Warn about missing requirements instead of an error.') { $WARN = true }
  opts.on('--export', 'Export data to current directory as separate files.') { $EXPORT = true }
  opts.on('--build OUTPUT', 'Re-build to named script.') { |f| $BUILD = f }
  opts.on('-i', '--input FILENAME', 'Specifications to use.') { |f| $IN = f }
  opts.on('-h', '--help', 'Print this help and exit.') do
    STDOUT.puts opts
    exit 0
  end
end
parser.parse!

#$PIECESASSIGNMENTSTART#
$PIECES = {}
$FILECONTENTS = {}
#$PIECESASSIGNMENTEND#

if $CLEAN
  $PIECES = {}
  $FILECONTENTS = {}
end

$FILECONTENTS.each_pair do |key, value|
  $FILECONTENTS[key] = Base64.decode64(value)
end

def load_piece_file(piece, field, directory)
  filename = piece.fetch(field, nil)
  if filename.nil?
    piece[field] = nil
    piece["#{field}_stored"] = nil
    return
  end
  begin
    filename = File.realpath(filename, directory)
    puts filename
    f = File.new(filename, 'r')
    content = IO.read(f)
    f.close
  rescue StandardError
    STDERR.puts "Failed to open/read: #{filename}"
    exit(3)
  end
  stored = nil
  keys = $FILECONTENTS.keys
  for k in 0..keys.size
    if $FILECONTENTS[keys[k]] == content
      stored = keys[k]
      break
    end
  end
  if stored.nil?
    stored = "c#{$FILECONTENTS.size}"
    $FILECONTENTS[stored] = content
  end
  piece["#{field}_stored"] = stored
end

def default(spec, field, value)
  spec[field] = value unless spec.has_key? field
end

def default_array(spec, field, value)
  default(spec, field, value)
  unless spec[field].is_a? Array
    spec[field] = [ spec[field] ]
  end
end

def load_spec(filename, root=nil)
  begin
    unless root.nil?
      filename = File.realpath(filename, root)
      puts filename
    end
    f = File.open(filename, 'r')
    input = IO.read(f)
    f.close
  rescue StandardError
    STDERR.puts "Failed to find/read #{filename}"
    exit(3)
  end
  begin
    specs = JSON.parse(input)
  rescue StandardError
    begin
      specs = YAML.load(input)
    rescue StandardError
      STDERR.puts "#{filename} neither JSON nor YAML."
      exit(3)
    end
  end
  return specs
end

unless $RECIPE.nil?
  recipe = load_spec($RECIPE)
  root = File.dirname(File.realpath($RECIPE))
  unless recipe.is_a? Array
    STDERR.puts 'Recipe file must be a YAML array of file names.'
    exit(2)
  end
  recipe.each do |filename|
    piece = load_spec(filename, root)
    d = File.dirname(File.realpath(filename, root))
    piece.each_pair do |name, spec|
      load_piece_file(spec, 'header', d)
      load_piece_file(spec, 'source', d)
      load_piece_file(spec, 'license', d)
      default_array(spec, 'includes', [])
      default_array(spec, 'source_includes', [])
      default_array(spec, 'requires', [])
      default(spec, 'writer', false)
      default(spec, 'scalar', true)
      default(spec, 'external', not(spec['writer']))
      default(spec, 'declaration', nil)
      default(spec, 'pooled', nil)
      default(spec, 'poolindexes', nil)
      default(spec, 'poolparsers', nil)
      default(spec, 'poolparsertypes', nil)
      default(spec, 'parsername', spec['writer'] ? nil : "Parse#{name}")
      # Either use for writer template type or drop.
      #default(spec, 'c++type', spec['writer'] ? nil : spec['parsername'])
      unless spec['pooled'].nil?
        [ 'poolindexes', 'poolparsers', 'poolparsertypes' ].each do |field|
          raise ArgumentError.new("#{name} has both pooled and #{field}") unless spec[field].nil?
        end
      end
      puts("Replacing #{name}") if $PIECES.has_key? name
      $PIECES[name] = spec
    end
  end
end

if $LIST
  all = []
  $PIECES.each_pair do |name, piece|
    all.push("#{name}#{piece['external'] ? '' : ' (internal)'}")
  end
  all.sort!
  puts all
end

# Check that requirements are met.
missing = false
$PIECES.each_pair do |name, spec|
  spec['requires'].each do |r|
    unless $PIECES.has_key? r
      STDERR.puts "#{name} missing requirement: #{r}"
      missing = true
    end
  end
end
exit(4) if missing and not $WARN

if $EXPORT
  pieces = {}
  name2store = {}
  $PIECES.each_pair do |name, piece|
    piece = piece.clone
    [ 'header', 'source', 'license' ].each do |field|
      next if piece[field].nil?
      b = File.basename piece[field]
      s = piece["#{field}_stored"]
      if name2store.has_key? b
        name2store[b].push(s) unless name2store[b].include? s
      else
        name2store[b] = [ s ]
      end
      piece[field] = b
    end
    pieces[name] = piece
  end
  collisions = []
  name2store.each_pair do |b, s|
    if s.size == 1
      f = File.new(b, 'w')
      f.write($FILECONTENTS[s[0]])
      f.close
    else
      collisions.push b
    end
  end
  store2name = {}
  collisions.each do |b|
    s = name2store[b]
    name2store.delete b
    pre = File.basename(b, '.*')
    ext = b.slice(pre.size, b.size - pre.size)
    idx = 0
    bn = b
    s.each do |c|
      while name2store.has_key? bn
        idx += 1
        bn = "#{pre}_#{idx}#{ext}"
      end
      store2name[c] = bn
      f = File.new(bn, 'w')
      f.write($FILECONTENTS[c])
      f.close
      name2store[bn] = [ c ]
    end
  end
  list = []
  pieces.each_pair do |name, piece|
    [ 'header', 'source', 'license' ].each do |field|
      if piece[field].nil?
        piece.delete field
      else
        s = piece["#{field}_stored"]
        if store2name.has_key? s
          piece[field] = store2name[s]
        end
      end
      piece.delete "#{field}_stored"
    end
    list.push "#{name}.yaml"
    f = File.new(list.last, 'w')
    f.write(YAML.dump({ name => piece }))
    f.close
  end
  f = File.new('exported.yaml', 'w')
  f.write(YAML.dump(list))
  f.close
end

unless $BUILD.nil?
  script = File.new($0, chomp: true).readlines
  first = script.find_index { |ln| ln.start_with? '#$PIECESASSIGNMENTSTART#' }
  last = script.find_index { |ln| ln.start_with? '#$PIECESASSIGNMENTEND#' }
  if first.nil? or last.nil? or last < first
    STDERR.puts 'Failed to find lines starting with or in wrong order: #$PIECESASSIGNMENTSTART# #$PIECESASSIGNMENTEND#'
    exit(2)
  end
  succeeding = script.slice(last, script.size - last).join
  script = script.slice(0, first + 1).join
  encoded = {}
  $FILECONTENTS.each_pair do |key, value|
    encoded[key] = Base64.encode64(value)
  end
  script.concat(%Q(
$PIECES = YAML.load(%Q(#{YAML.dump($PIECES)}))
$FILECONTENTS = YAML.load(%Q(#{YAML.dump(encoded)}))
))
  script.concat(succeeding)
  IO.write($BUILD, script)
  File.chmod(0755, $BUILD)
end

exit(0) if $IN.nil?

specs = load_spec($IN)

$PIECES.each_pair { |name, piece| piece['name'] = name }

def all_requirements(piece, reqs)
  unless reqs.include? piece['name']
    reqs.push piece['name']
    piece['requires'].each do |r|
      next if reqs.include? r
      all_requirements($PIECES[r], reqs)
    end
  end
  return reqs
end

$PIECES.each_value do |piece|
  piece['all_requires'] = all_requirements(piece, [])
end

def parserpool_substitutions(needed, namespace)
  $pools = []
  $pooled = []
  needed.each do |name|
    piece = $PIECES[name]
    $pools.push(name) unless piece['poolindexes'].nil? and piece['poolparsers'].nil? and piece['poolparsertypes'].nil?
    $pooled.push(name) unless piece['pooled'].nil?
    [ 'header', 'source' ].each do |field|
      fc = piece["#{field}_stored"]
      next if fc.nil?
      piece["#{field}_content"] = String.new($FILECONTENTS[fc])
      next if 'specjson' == namespace
      until piece["#{field}_content"].sub!('specjson::', "#{namespace}::").nil?
      end
    end
  end
  poolvals = {
    'poolindexes' => [],
    'poolparsers' => [],
    'poolparsertypes' => []
  }
  $pooled.each_index do |k|
    piece = $PIECES[$pooled[k]]
    poolvals['poolindexes'].push $pooled[k]
    poolvals['poolparsers'].push piece['parsername']
    poolvals['poolparsertypes'].push "#{piece['parsername']}::Type"
    [ 'header', 'source' ].each do |field|
      fc = piece["#{field}_stored"]
      next if fc.nil?
      until piece["#{field}_content"].sub!(piece['pooled'], k.to_s).nil?
      end
    end
  end
  poolvals.each_pair { |k, v| poolvals[k] = v.join(', ') }
  $pools.each do |name|
    piece = $PIECES[name]
    [ 'header', 'source' ].each do |field|
      fc = piece["#{field}_stored"]
      next if fc.nil?
      poolvals.each_pair do |fld, value|
        until piece["#{field}_content"].sub!(piece[fld], value).nil?
        end
      end
    end
  end
end

def licenses(needed)
  lic2id = { }
  needed.each do |name|
    lic = $PIECES[name]['license_stored']
    next if lic.nil? or lic2id.has_key? lic
    lic2id[lic] = "License #{lic2id.size + 1}"
  end
  return lic2id
end

def compare_pieces(a, b)
  a = $PIECES[a]
  b = $PIECES[b]
  # Group writers at the end.
  if a['writer']
    return 1 unless b['writer']
  else
    return -1 if b['writer']
  end
  areqs = a['all_requires']
  breqs = b['all_requires']
  if areqs.include? b['name']
    return areqs.length <=> breqs.length if breqs.include? a['name']
    return 1
  end
  return -1 if breqs.include? a['name']
  if a['writer'] and b['writer']
    if a['scalar']
      return -1 unless b['scalar']
    else
      return 1 if b['scalar']
    end
  end
  # Neither requires the other. Keep pools and pooled items before others.
  if $pooled.include? a['name']
    return -1 unless $pooled.include? b['name']
  else
    return 1 if $pooled.include? b['name']
  end
  if $pools.include? a['name']
    return -1 unless $pools.include? b['name']
  else
    return 1 if $pools.include? b['name']
  end
  return areqs.length <=> breqs.length unless areqs.length == breqs.length
  return a['name'] <=> b['name']
end

def arrange_needed(needed)
  pools = needed.select { |name| $pools.include? name }
  others = needed.select { |name| not(pools.include?(name)) }
  others.sort! { |a, b| compare_pieces(a, b) }
  last = others.rindex { |name| $pooled.include? name }
  needed = others.slice!(0, last + 1)
  others.concat pools
  others.sort! { |a, b| compare_pieces(a, b) }
  needed.concat others
  return needed
end

def unique_in_order(piece_names, field)
  values = []
  piece_names.each do |name|
    piece = $PIECES[name]
    next if piece[field].nil?
    if piece[field].is_a? String
      values.push(piece[field]) unless values.include? piece[field]
    else
      piece[field].each do |line|
        values.push(line) unless values.include? line
      end
    end
  end
  return values
end

def license_block(lic2id)
  blocks = []
  lic2id.each_pair do |lic, id|
    blocks.push %Q(
#if 0
/*
#{id}:

#{$FILECONTENTS[lic]}
*/
#endif
)
  end
  return blocks.join("\n")
end

def make_header(spec, piece_names, generated, lic2id)
  h = File.new(spec['header'], 'w')
  h.puts %Q(// Auto-generated file. Do not edit.
#if !defined(#{spec['header'].upcase.sub('.', '_')})
#define #{spec['header'].upcase.sub('.', '_')}

#{license_block(lic2id)}
)
  h.puts %Q(
#{unique_in_order(piece_names, 'includes').join("\n")}

namespace #{spec['namespace']} {

#{unique_in_order(piece_names, 'declaration').join("\n")}
#{(generated.keys.map { |k| generated[k][:forward].join("\n") }).join("\n")}
)
  prev = nil
  piece_names.each do |name|
    piece = $PIECES[name]
    next if piece['header_stored'].nil?
    lic = piece['license_stored']
    if lic != prev
      h.puts
      h.puts(lic.nil? ? '// Unspecified license.' : "// Under #{lic2id[lic]}.")
      prev = lic
    end
    h.puts
    h.puts "// Origin: #{piece['header']}"
    h.puts(piece['header_content'])
  end
  generated.each_pair do |typename, object|
    h.puts %Q(
// #{typename}
#{object[:extern].join("\n")}

#{object[:typedef].join("\n")}

#{object[:class].join("\n")}
)
  end
  h.puts %Q(
} // namespace #{spec['namespace']}

#endif)
  h.close
  return spec['header']
end

def make_source(spec, piece_names, generated, lic2id, header_name)
  h = File.new(spec['source'], 'w')
  h.puts %Q(// Auto-generated file. Do not edit.
#{license_block(lic2id)}

#define INCLUDED_FROM_GENERATED_SOURCE 1
#include "#{header_name}"
#undef INCLUDED_FROM_GENERATED_SOURCE
#{unique_in_order(piece_names, 'source_includes').join("\n")}

using namespace #{spec['namespace']};
)
  prev = nil
  piece_names.each do |name|
    piece = $PIECES[name]
    next if piece['source_stored'].nil?
    lic = piece['license_stored']
    if lic != prev
      h.puts
      h.puts(lic.nil? ? '// Unspecified license.' : "// Under #{lic2id[lic]}.")
      prev = lic
    end
    h.puts
    h.puts "// Origin: #{piece['source']}"
    h.puts(piece['source_content'])
  end
  generated.each_pair do |typename, object|
    h.puts %Q(
// #{typename}
#{object[:extern_src].join("\n")}
)
  end
  h.close
  return spec['source']
end

def assure(spec, field, error)
  return if spec.has_key? field
  STDERR.puts error
  exit(4)
end

specs.each_pair do |name, spec|
  default(spec, 'namespace', 'specjson')
  default(spec, 'standalone', false)
  default(spec, 'types', { })
  default(spec, 'generate', { })
  default(spec, 'name', name)
  default(spec, 'header_extension', 'hpp')
  default(spec, 'source_extension', 'cpp')
  default(spec, 'header', "#{spec['name']}.#{spec['header_extension']}")
  default(spec, 'source', "#{spec['name']}.#{spec['source_extension']}")
  spec['generate'].each_pair do |typename, gen|
    unless spec['types'].has_key? typename
      STDERR.puts "#{name} generate #{typename} has no match in types: #{spec['types'].keys.sort.join(' ')}"
      exit(4)
    end
    default(gen, 'parser', false)
    default(gen, 'writer', false)
  end
  spec['types'].each_pair do |typename, object|
    unless spec['generate'].has_key? typename
      puts "#{name} #{typename} deleted since it has no match in generate: #{spec['generate'].keys.sort.join(' ')}"
      spec['types'].delete typename
      next
    end
    object[:requires] = []
    object.each_pair do |field, desc|
      next unless desc.is_a? Hash
      if spec['generate'][typename]['parser']
        assure(desc, 'format', "#{name} #{typename} #{field} has no 'format'.")
        unless desc['format'].is_a? Array
          desc['format'] = [ desc['format'] ]
        end
        object[:requires].concat desc['format']
      end
      default(desc, 'required', true)
      gen = spec['generate'][typename]
      if gen['writer'] and not gen['parser'] # Parser sets defaults later.
        if desc['required']
          default(desc, 'checker', nil) # Will not be used.
        else
          assure(desc, 'checker', "#{name} #{typename} #{field} has no 'checker'.")
        end
        assure(desc, 'accessor', "#{name} #{typename} #{field} has no 'accessor'.")
      end
    end
  end
  spec['types'].each_pair do |typename, object|
    object.each_pair do |field, desc|
      next unless desc.is_a? Hash
      next unless spec['generate'][typename]['parser']
      desc['format'].each do |f|
        unless f.is_a? String
          STDERR.puts "#{name} #{typename} #{field} format not string."
          exit(4)
        end
        if $PIECES.has_key? f
          object[:requires].push f
          next if $PIECES[f]['external']
          STDERR.puts "#{name} #{typename} #{field} format #{f} internal."
          exit(4)
        end
        if spec['generate'].has_key? f
          next if spec['generate'][f]['parser']
          STDERR.puts "#{name} #{typename} #{field} format #{f} no parser."
          exit(4)
        end
        if spec['types'].has_key? f
          STDERR.puts "#{name} #{typename} #{field} format #{f} not generated."
        else
          STDERR.puts "#{name} #{typename} #{field} format #{f} not found: #{spec['types'].keys.sort.join(' ')}"
        end
        exit(4)
      end
    end
    object[:requires].uniq!
  end
end

def classify_expression(expr)
  # Simple but good enough for now. If expression gets confused with method,
  # add space in any place where it does not affect the meaning.
  return :expression if expr.nil? # Will go unused in this case.
  return :expression if expr.include? ' '
  return :expression if expr.include?('.') or expr.include?('->')
  return :method if expr.end_with? '()'
  return :member
end

def write_function(spec, typename)
  object = spec['types'][typename]
  all_req = true
  object.each_pair do |field, desc|
    all_req = false unless desc['required']
  end
  lines = [ %Q(
#if !defined(INCLUDED_FROM_GENERATED_SOURCE)
template<typename Sink>
void Write(Sink& S, const #{typename}& Value, std::vector<char>& Buffer) {
    char c = '{';
    S.write(&c, 1);) ]
  lines.push('    bool separated = true;') unless all_req
  prev_req = nil
  names = []
  fields = object.keys
  # If write order is ever something other than the key one, change it here.
  fields.each do |field|
    desc = object[field]
    fill = ''
    unless desc['required']
      lines.push "    if (Value.#{desc['checker']}) {"
      fill = '    '
    end
    if all_req or prev_req
      lines.push "#{fill}    c = ',';"
      lines.push "#{fill}    S.write(&c, 1);"
    elsif not prev_req.nil?
      lines.push "#{fill}    if (!separated) {"
      lines.push "#{fill}        c = ',';"
      lines.push "#{fill}        S.write(&c, 1);"
      lines.push "#{fill}    }"
    end
    lines.push "#{fill}    Write(S, #{typename}_#{field}, Buffer);"
    lines.push "#{fill}    c = ':';"
    lines.push "#{fill}    S.write(&c, 1);"
    lines.push "#{fill}    Write(S, Value.#{desc['accessor']}, Buffer);"
    lines.push("#{fill}    separated = false;") unless all_req or field == fields.last
    lines.push('    }') unless desc['required']
    prev_req = desc['required']
  end
  lines.push %Q(    c = '}';
    S.write(&c, 1);
}
#endif // INCLUDED_FROM_GENERATED_SOURCE
)
  return lines.join("\n")
end

specs.each_pair do |name, spec|
  needed = []
  spec['generate'].each_pair do |typename, gen|
    next unless spec['types'][typename].has_key? :requires
    needed.concat spec['types'][typename][:requires]
    spec['types'][typename].delete :requires
  end
  if needed.empty?
    unless spec['standalone']
      puts "#{name} needs nothing and not standalone, skipped."
      next
    end
    needed = $PIECES.keys
  else
    if spec['standalone']
      needed.concat($PIECES.keys)
    else
      $PIECES.each_pair do |name, piece|
        needed.push(name) if piece['writer']
      end
    end
    needed.uniq!
  end
  parserpool_substitutions(needed, spec['namespace'])
  needed = arrange_needed(needed)
  lic2id = licenses(needed)
  generated = { }
  spec['generate'].each_pair do |typename, gen|
    object = spec['types'][typename]
    out = {
      :forward => [],
      :typedef => [],
      :extern => [],
      :extern_src => [],
      :class => []
    }
    if gen['parser']
      out[:forward].push "class #{typename};"
      keyvalues = []
      values = []
      names = []
      object.each_pair do |field, desc|
        sub = "#{typename}_#{field}"
        # Field name string constant.
        out[:extern].push "extern const char #{sub}[];"
        out[:extern_src].push "const char #{spec['namespace']}::#{sub}[] = \"#{field}\";"
        prev = nil
        k = desc['format'].size - 1
        f = desc['format'][k]
        p = $PIECES[f]
        out[:typedef].push "typedef #{p['parsername']} #{sub}_#{k.to_s};"
        while k > 0
          k -= 1
          f = desc['format'][k]
          p = $PIECES[f]
          out[:typedef].push "typedef #{p['parsername']}<#{sub}_#{(k + 1).to_s}> #{sub}_#{k.to_s};"
        end
        keyvalues.push "#{desc['required'] ? 'Required' : ''}Key#{(desc['format'].size > 1) ? 'Container' : ''}Value<#{sub},#{sub}_0>"
        out[:typedef].push "typedef #{keyvalues.last} #{sub}_KeyValue;"
        values.push "Value<#{sub}_0>"
        names.push field
        default(desc, 'accessor', "#{field}()")
        desc[:access_type] = classify_expression(desc['accessor'])
        default(desc, 'checker', "#{field}Given()")
        desc[:check_type] = classify_expression(desc['checker'])
      end
      out[:typedef].push "typedef KeyValues<#{keyvalues.join(',')}> #{typename}_KeyValues;"
      out[:typedef].push "typedef NamelessValues<#{values.join(',')}> #{typename}_NamelessValues;"
      out[:typedef].push "typedef ParseObject<#{typename}_KeyValues,#{typename}_NamelessValues> #{typename}_Parser; // Parse with an instance of this."
      out[:class].push %Q(
class #{typename} {
public:
#{(names.map { |n| "    typedef #{values[names.find_index(n)]}::Type #{n}Type;"}
).join("\n")}
    #{typename}_Parser::Type values;

#{(names.map { |n| "    bool #{n}Given() const { return std::get<#{names.find_index(n)}>(values).Given(); }"}).join("\n")}

#{(names.map { |n| "    #{n}Type& #{n}() { return std::get<#{names.find_index(n)}>(values).value; }"}).join("\n")}
#{(names.map { |n| "    const #{n}Type& #{n}() const { return std::get<#{names.find_index(n)}>(values).value; }"}).join("\n")}
};
)
      if gen['writer']
        out[:class].push write_function(spec, typename)
      end
      generated[typename] = out
    elsif gen['writer']
      object.each_pair do |field, desc|
        sub = "#{typename}_#{field}"
        out[:extern].push "extern const char #{sub}[];"
        out[:extern_src].push "const char #{spec['namespace']}::#{sub}[] = \"#{field}\";"
        desc[:access_type] = classify_expression(desc['accessor'])
        desc[:check_type] = classify_expression(desc['checker'])
        desc[:tn] = "T_#{field}"
      end
      # Template class for write.
      get_ind = object.keys.select { |k| object[k][:access_type] == :method }
      get_dir = object.keys.select { |k| object[k][:access_type] != :method }
      chk_ind = object.keys.select { |k| object[k][:check_type] == :method and not object[k][:required] }
      tmpl = [ %Q(
template<#{(object.keys.map { |k| "typename #{object[k][:tn]}" }).join(',')}>
class #{typename}_Template {
private:
#{(get_ind.map { |f| "    #{object[f][:tn]} #{f}_value;" }).join("\n")}

#{(chk_ind.map { |f| "    bool #{f}_given;" }).join("\n")}

public:) ]
      unless chk_ind.empty? # Constructor to set given indicators to false.
        tmpl.push "    #{typename}_Template() : #{(chk_ind.map { |f| "#{f}_given(false)" }).join(', ')} { }"
      end
      tmpl.push(%Q(
#{(chk_ind.map { |f| "    bool& #{object[f][:checker]} { return #{f}_given; }" }).join("\n")}
#{(chk_ind.map { |f| "    bool #{object[f][:checker]} const { return #{f}_given; }" }).join("\n")}

#{(get_dir.map { |f| "    #{object[f][:tn]} #{f};" }).join("\n")}

#{(get_ind.map { |f| "    #{object[f][:tn]}& #{object[f]['accessor']} { return #{f}_value; };" }).join("\n")}
#{(get_ind.map { |f| "    const #{object[f][:tn]}& #{object[f]['accessor']} const { return #{f}_value; }" }).join("\n")}
};))
      tmpl = tmpl.join("\n")
      # Tweak the looks of output.
      until (tmpl.sub!("\n\n\n", "\n\n")).nil? # Shrink two empty lines to 1.
      end
      tmpl.sub!("private:\n\n", "private:\n")
      tmpl.sub!("public:\n\n", "public:\n")
      tmpl.sub!("private:\npublic:", "public:") # Drop private if not used.
      tmpl.sub!("\n\n};", "\n};")
      out[:class].push tmpl
      # define check and typedef for template.
      out[:class].push %Q(
#if defined(#{spec['namespace'].upcase}_#{typename.upcase}_TYPE)
typedef #{spec['namespace'].upcase}_#{typename.upcase}_TYPE #{typename};
#endif
)
      out[:class].push write_function(spec, typename)
      generated[typename] = out
    end
  end
  puts "#{name}: #{generated.keys.join(' ')} #{needed.join(' ')}"
  hdr = make_header(spec, needed, generated, lic2id)
  src = make_source(spec, needed, generated, lic2id, hdr)
  puts "  Header: #{hdr}, source: #{src}"
end
