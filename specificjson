#!/usr/bin/env ruby

# Copyright 2020 Ismo Kärkkäinen
# Licensed under Universal Permissive License. See License.txt.

require 'optparse'
require 'json'

$VERBOSE = false
$IN = nil

parser = OptionParser.new do |opts|
  opts.summary_indent = '  '
  opts.summary_width = 26
  opts.banner = "Usage: specificjson [options]"
  opts.separator ""
  opts.separator "Options:"
  opts.on('-i', '--input FILENAME') { |f| $IN = f }
  opts.on('--verbose', 'Verbose output to stderr.') { $VERBOSE = true }
  opts.on('-h', '--help', 'Print this help and exit.') do
    STDOUT.puts opts
    exit 0
  end
end
parser.parse!

def file(val, default, mode)
  return default if val.nil?
  begin
    return File.open(val, mode)
  rescue StandardError
    STDERR.puts "Failed to open for #{mode}: #{val}"
    exit 1
  end
end

def aargh(message)
  raise ArgumentError.new(message)
end

# Parser to type etc. mapping.
$simples = {
  'string' => {
    :cont => false,
    :fmt => 'ParseString',
    :include => 'JSONParsers.hpp' },
  'float' => {
    :cont => false,
    :fmt => 'ParseFloat',
    :include => 'JSONParsers.hpp' },
  'integer' => {
    :cont => false,
    :fmt => 'ParseInt',
    :include => 'JSONParsers.hpp' },
  'array' => {
    :cont => true,
    :fmt => 'ParseArray<%s>',
    :include => 'JSONParsers.hpp' },
  'object' => {
    :cont => true,
    :fmt => 'ParseObject<%s,%s>',
    :include => 'JSONParsers.hpp' }
}
$containers = {
  'array' => {
    :cont => true,
    :fmt => 'ParseContainerArray<%s>',
    :include => 'JSONParsers.hpp' }
}

def check_input(format)
  format = [ format ] unless format.is_a? Array
  item = format.shift
  if item.is_a? String
    contained = []
    size = format.size
    contained = check_input(format) unless format.empty?
    if contained.empty? or contained.first[:cont] == false
      ti = $simples.fetch(item)
    else
      ti = $containers.fetch(item)
    end
    # Should check if top-level has a matching object?
    aargh("input format: #{item}") if ti.nil?
    aargh("input format: non-container not last: #{item}") if 0 < size and ti[:cont] == false
    aargh("input format: container last: #{item}") if size == 0 and ti[:cont]
    info = [ ti ]
    info.concat(contained) unless contained.empty?
    return info
  end
  # Object.
  info = []
  object_name = nil
  item.each_pair do |name, spec|
    if name == '-typename-'
        object_name = spec
        next
    end
    items = spec.fetch('format', nil)
    aargh("input #{name} no format") if items.nil?
    fmt = check_input(items)
    info.push({
      :name => name,
      :req => spec.fetch('required', false),
      :fmt => fmt,
      :cont => ((fmt.size >= 1) and fmt[0][:cont])
    })
  end
  return {
    :object => $simples['object'],
    :fields => info,
    :name => object_name
  }
end

def check_output(format)
  return {} if format.nil?
  format = [ format ] unless format.is_a? Array
  item = format.shift
  if item.is_a? String
    info = [ { :include => 'JSONWriters.hpp' } ]
    reqs = []
    unless format.empty?
      contained = check_output(format)
      info.concat(contained)
      reqs = contained.first.fetch(:deps, []);
    end
    info.first[:deps] = reqs
    return info
  end
  # Object.
  info = []
  object_name = nil
  reqs = []
  separator = '.'
  item.each_pair do |name, spec|
    if name == '-typename-'
      object_name = spec
      next
    end
    if name == '-separator-'
      separator = spec
      next
    end
    items = spec.fetch('format', nil)
    aargh("output #{name} no format") if items.nil?
    fmt = check_output(items)
    reqs.concat(fmt.first[:deps])
    info.push({
      :name => name,
      :req => spec.fetch('required', false),
      :fmt => fmt,
      :checker => spec.fetch('-checker-', "#{name}Given()"),
      :getter => spec.fetch('-getter-', "#{name}()")
    })
  end
  aargh("output no object name") if object_name.nil?
  return {
    :fields => info,
    :name => object_name,
    :deps => reqs,
    :sep => separator
  }
end

input = file($IN, STDIN, 'r')
specs = JSON.parse(input.gets(nil))
parsed = {}
specs.each_pair do |basename, spec|
  incoming = check_input(spec.fetch('input', nil))
  outgoing = check_output(spec.fetch('output', nil))
  if incoming.fetch(:fields, []).empty? and outgoing.fetch(:fields, []).empty?
    aargh("#{basename} no input nor output")
  end
  parsed[basename] = { :in => incoming, :out => outgoing }
end

# Figure out type names etc. from formats.

$basename = ''
$types = {}
$lines = []
$includes = []
def add_type(t, typename=nil)
  unless $types.has_key? t
    tn = typename.nil? ? "#{$basename}#{$types.size}" : typename
    $types[t] = tn
    $lines.push "typedef #{t} #{tn};"
  end
  return $types[t]
end

def add_static(t)
  unless $types.has_key? t
    n = "#{$basename}#{$types.size}Name"
    $types[t] = n
    $lines.push "static const char #{n}[] = \"#{t}\";";
  end
  return $types[t]
end

def add_named_type(names, values, base)
  t = "#{base}Values"
  unless $types.has_key? t
    $types[t] = t
    $lines.push(%Q(
class #{t} {
public:
#{(names.map { |n| "    typedef #{values[names.find_index(n)]}::Type #{n}Type;"}).join("\n")}
    #{base}::Type values;

#{(names.map { |n| "    bool #{n}Given() const { return std::get<#{names.find_index(n)}>(values).Given(); }"}).join("\n")}

#{(names.map { |n| "    #{n}Type& #{n}() { return std::get<#{names.find_index(n)}>(values).value; }"}).join("\n")}
#{(names.map { |n| "    const #{n}Type& #{n}() const { return std::get<#{names.find_index(n)}>(values).value; }"}).join("\n")}
};
))
  end
  return t
end

def define_types(info)
  return '' if info.empty?
  if info.is_a? Array
    this = info.shift
    $includes.push(this[:include]) if this.has_key? :include
    return add_type(this[:fmt] % define_types(info))
  else
    $includes.push(info[:include]) if info.has_key? :include
    keyvalues = []
    values = []
    names = []
    info[:fields].each do |field|
      parser = define_types(field[:fmt])
      n = add_static(field[:name])
      keyvalues.push add_type("#{field[:req] ? 'Required' : ''}Key#{field[:cont] ? 'Container' : ''}Value<#{n},#{parser}>")
      values.push add_type("Value<#{parser}>")
      names.push field[:name]
    end
    kvs = add_type("KeyValues<#{keyvalues.join(',')}>")
    nvs = add_type("NamelessValues<#{values.join(',')}>")
    parser = add_type(info[:object][:fmt] % [ kvs, nvs ], info[:name])
    vs = add_named_type(names, values, parser)
  end
end

def classify_expression(expr)
  # Simple but good enough for now. If expression gets confused with method,
  # add space in any place where it does not affect the meaning.
  return :expression if expr.include? ' '
  return :expression if expr.include?('.') or expr.include?('->')
  return :method if expr.end_with? '()'
  return :member
end

def define_function(info)
  # Add to types an object with lines and requirements.
  info[:fields].each do |f|
    $includes.push(f[:include]) if f.has_key? :include
  end
  fields = info[:fields]
  # Forward declaration for the type name used below.
  # Then you can use the generated template (if any) with typedef if needed.
  lines = [
    "\n\n#if defined(#{info[:name].upcase}_TYPE)",
    "typedef #{info[:name].upcase}_TYPE #{info[:name]};",
    '#endif'
  ]
  fwd = %Q(template<typename Sink>
void Write(Sink& S, const #{info[:name]}& Value, std::vector<char>& Buffer))
  lines.push %Q(
#{fwd} {
    char c = '{';
    bool separated = true;
    S.write(&c, 1);)
  prev_req = false
  names = []
  fields.each_index do |idx|
    f = fields[idx]
    f[:idx] = idx
    f[:tn] = "T#{idx}"
    f[:chk_type] = classify_expression(f[:checker])
    f[:get_type] = classify_expression(f[:getter])
    fill = ''
    unless f[:req]
      lines.push "    if (Value#{info[:sep]}#{f[:checker]}) {"
      fill = '    '
    end
    if prev_req
      lines.push("#{fill}    c = ',';")
      lines.push("#{fill}    S.write(&c, 1);")
    elsif idx > 0
      lines.push("#{fill}    if (!separated) {")
      lines.push("#{fill}        c = ',';")
      lines.push("#{fill}        S.write(&c, 1);")
      lines.push("#{fill}    }")
    end
    lines.push "#{fill}    Write(S, \"#{f[:name]}\", Buffer);"
    lines.push "#{fill}    c = ':';"
    lines.push "#{fill}    S.write(&c, 1);"
    lines.push "#{fill}    Write(S, Value#{info[:sep]}#{f[:getter]}, Buffer);"
    lines.push "#{fill}    separated = false;" unless idx + 1 == fields.size
    lines.push('    }') unless f[:req]
    prev_req = f[:req]
  end
  lines.push %Q(    c = '}';
    S.write(&c, 1);
}
)
  # Those that have method as getter.
  get_ind = fields.select { |f| f[:get_type] == :method }
  # Those that are not accessed via method.
  get_dir = fields.select { |f| f[:get_type] != :method }
  # Those optional fields that are checked via a method using bool member.
  chk_ind = fields.select { |f| f[:chk_type] == :method and not f[:req] }

  tmpl = [ %Q(
template<#{(fields.map { |f| "typename #{f[:tn]}" }).join(',')}>
class #{info[:name]}Template {
private:
#{(get_ind.map { |f| "    #{f[:tn]} #{f[:name]}_value;" }).join("\n")}

#{(chk_ind.map { |f| "    bool #{f[:name]}_given;" }).join("\n")}

public:) ]
  unless chk_ind.empty?
    tmpl.push "    #{info[:name]}Template() : #{(chk_ind.map { |f| "#{f[:name]}_given(false)" }).join(', ')} { }"
  end
  tmpl.push(%Q(
#{(chk_ind.map { |f| "    bool& #{f[:checker]} { return #{f[:name]}_given; }" }).join("\n")}
#{(chk_ind.map { |f| "    bool #{f[:checker]} const { return #{f[:name]}_given; }" }).join("\n")}

#{(get_dir.map { |f| "    #{f[:tn]} #{f[:name]};" }).join("\n")}

#{(get_ind.map { |f| "    #{f[:tn]}& #{f[:getter]} { return #{f[:name]}_value; };" }).join("\n")}
#{(get_ind.map { |f| "    const #{f[:tn]}& #{f[:getter]} const { return #{f[:name]}_value; }" }).join("\n")}
};))
  tmpl = tmpl.join("\n")
  # Tweak the looks of output.
  while not (tmpl.sub!("\n\n\n", "\n\n")).nil? # Shrink two empty lines to 1.
  end
  tmpl.sub!("private:\n\n", "private:\n")
  tmpl.sub!("public:\n\n", "public:\n")
  tmpl.sub!("private:\npublic:", "public:") # Drop private if not used.
  tmpl.sub!("\n\n};", "\n};")
  return {
    :name => info[:name],
    :fwd => fwd + ';',
    :lines => tmpl + lines.join("\n"),
    :deps => info.fetch(:deps, []).uniq
  }
end

def add_named_type(names, values, base)
  t = "#{base}Values"
  unless $types.has_key? t
    $types[t] = t
    $lines.push(%Q(
class #{t} {
public:
#{(names.map { |n| "    typedef #{values[names.find_index(n)]}::Type #{n}Type;"}).join("\n")}
    #{base}::Type values;

#{(names.map { |n| "    bool #{n}Given() const { return std::get<#{names.find_index(n)}>(values).Given(); }"}).join("\n")}

#{(names.map { |n| "    #{n}Type& #{n}() { return std::get<#{names.find_index(n)}>(values).value; }"}).join("\n")}
#{(names.map { |n| "    const #{n}Type& #{n}() const { return std::get<#{names.find_index(n)}>(values).value; }"}).join("\n")}
};
))
  end
  return t
end

def define_output_functions(info)
  return '' if info.empty?
  if info.is_a? Array
    this = info.shift
    $includes.push(this[:include]) if this.has_key? :include
    define_output_functions(this)
    define_output_functions(info)
  else
    return if info.fetch(:fields, nil).nil? # Only objects get a function.
    return unless $types.fetch(info[:name], nil).nil? # Name is unique.
    $types[info[:name]] = define_function(info)
  end
end

parsed.each_pair do |basename, spec|
  $basename = basename
  define_types(spec[:in])
  spec[:in][:lines] = $lines
  spec[:in][:includes] = $includes.uniq
  $types = {}
  $lines = []
  $includes = [ 'JSONWriters.hpp' ]
  define_output_functions(spec[:out])
  ordered = $types.values
  ordered.sort! do |a, b|
    anb = a[:deps].include? b[:name]
    bna = b[:deps].include? a[:name]
    return -1 if bna and not anb
    return 1 if anb and not bna
    # When they need each other, put one with fewer dependencies first.
    diff = a[:deps].size - b[:deps].size
    return diff unless diff == 0
    # Put shorter one first on guess that it represents lowe-level object.
    return a[:lines].size - b[:lines].size
  end
  ordered.each do |d|
    d[:deps].each do |dep|
      unless $types[dep][:fwd].nil?
        $lines.push $types[dep][:fwd]
        $types[dep][:fwd] = nil
      end
    end
    $lines.push d[:lines]
  end
  spec[:out][:lines] = $lines
  spec[:out][:includes] = $includes.uniq
  $types = {}
  $lines = []
  $includes = []
end

def includes(ins, outs)
  all = ins[:includes]
  all.concat outs[:includes]
  all.uniq!
  lines = all.map do |filename|
    "#include \"#{filename}\""
  end
  return lines.join("\n")
end

parsed.each_pair do |basename, spec|
  h = file("#{basename}_io.hpp", STDOUT, 'w')
  h.puts %Q(// Auto-generated file. Do not edit.
#if !defined(IOGEN_#{basename.upcase}_IOHPP)
#define IOGEN_#{basename.upcase}_IOHPP
)
  h.puts includes(spec[:in], spec[:out])
  h.puts ''
  h.puts spec[:in][:lines].join("\n") unless spec[:in][:lines].empty?
  h.puts spec[:out][:lines].join("\n") unless spec[:out][:lines].empty?
  h.puts '#endif'
  h.close
end
